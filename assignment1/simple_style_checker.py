{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "c86be179-7109-438f-8e22-3dfb859c41ce",
   "metadata": {},
   "outputs": [],
   "source": [
    "import ast\n",
    "\n",
    "def is_camel_case(name):\n",
    "    return name[0].isupper() and name[1:].isalnum()\n",
    "\n",
    "def is_snake_case(name):\n",
    "    return name.islower() and \"_\" in name and \" \" not in name and name.replace(\"_\", \"\").isalnum()\n",
    "\n",
    "def style_check(file_path):\n",
    "    with open(file_path, 'r') as file:\n",
    "        content = file.read()\n",
    "\n",
    "    tree = ast.parse(content)\n",
    "    lines = content.splitlines()\n",
    "    total_lines = len(lines)\n",
    "    report = [f\"File Analysis Report for {file_path}\", f\"Total lines of code: {total_lines}\\n\"]\n",
    "\n",
    "    report.append(\"Imports:\")\n",
    "    imports = [node for node in ast.walk(tree) if isinstance(node, (ast.Import, ast.ImportFrom))]\n",
    "    if imports:\n",
    "        for imp in imports:\n",
    "            if isinstance(imp, ast.Import):\n",
    "                report.append(\"  - \" + \", \".join(alias.name for alias in imp.names))\n",
    "            else:\n",
    "                report.append(f\"  - from {imp.module} import \" + \", \".join(alias.name for alias in imp.names))\n",
    "    else:\n",
    "        report.append(\"  (No imports found)\")\n",
    "\n",
    "    classes = [node for node in ast.walk(tree) if isinstance(node, ast.ClassDef)]\n",
    "    functions = [node for node in ast.walk(tree) if isinstance(node, ast.FunctionDef) and not any(isinstance(parent, ast.ClassDef) for parent in ast.walk(tree))]\n",
    "\n",
    "    if classes:\n",
    "        report.append(\"\\nClasses:\")\n",
    "        for cls in classes:\n",
    "            report.append(f\"Class '{cls.name}':\")\n",
    "            docstring = ast.get_docstring(cls)\n",
    "            report.append(f\"  - Docstring: {docstring if docstring else 'Not found'}\")\n",
    "            if not is_camel_case(cls.name):\n",
    "                report.append(\"  - Naming issue: Should follow CamelCase\")\n",
    "\n",
    "            for method in [node for node in cls.body if isinstance(node, ast.FunctionDef)]:\n",
    "                report.append(f\"    Method '{method.name}':\")\n",
    "                docstring = ast.get_docstring(method)\n",
    "                report.append(f\"      - Docstring: {docstring if docstring else 'Not found'}\")\n",
    "                if not all(arg.annotation for arg in method.args.args) or method.returns is None:\n",
    "                    report.append(\"      - Type annotation missing\")\n",
    "                if not is_snake_case(method.name):\n",
    "                    report.append(\"      - Naming issue: Should follow snake_case\")\n",
    "\n",
    "    if functions:\n",
    "        report.append(\"\\nFunctions:\")\n",
    "        for func in functions:\n",
    "            report.append(f\"Function '{func.name}':\")\n",
    "            docstring = ast.get_docstring(func)\n",
    "            report.append(f\"  - Docstring: {docstring if docstring else 'Not found'}\")\n",
    "            if not all(arg.annotation for arg in func.args.args) or func.returns is None:\n",
    "                report.append(\"  - Type annotation missing\")\n",
    "            if not is_snake_case(func.name):\n",
    "                report.append(\"  - Naming issue: Should follow snake_case\")\n",
    "\n",
    "    if all(is_camel_case(cls.name) for cls in classes) and all(is_snake_case(func.name) for func in functions):\n",
    "        report.append(\"\\nAll naming conventions are correctly followed\")\n",
    "\n",
    "    if not any(node for node in ast.walk(tree) if isinstance(node, ast.FunctionDef) and (\n",
    "        not all(arg.annotation for arg in node.args.args) or node.returns is None)):\n",
    "        report.append(\"\\nAll functions and methods have type annotations\")\n",
    "\n",
    "    report_name = f\"style_report_{file_path.split('/')[-1].split('.')[0]}.txt\"\n",
    "    with open(report_name, 'w') as report_file:\n",
    "        report_file.write(\"\\n\".join(report))\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bd3bf29d-c6f7-4c0c-b212-7d80b9f4d359",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
